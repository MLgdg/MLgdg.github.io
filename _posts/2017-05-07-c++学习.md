---
layout:     post
title:      c++学习
subtitle:   
date:       2017-01-06
author:     高庆东
header-img: img/ceshi.jpg
catalog: true
tags:
    - c++
    - 面向对象
    - 指针
---

# c++

指针代表数组

Cin 流对象 对象类型是istream   提取操作 （相当于结构体）

Cin.ignore(7)接收到的表示忽略前7个字符

Cin.getlinr(buf,10)表示接收到10个字符存在buf里（字符串数组最后一位为0）

Cin.peek() 提取字符比较 

Cin.get() 获取字符

Cin.read(buf,20)读取20个字节进入

Cout.precision()

Cout.width()

- C++中任意位置可以声明变量

：：表示在某个类里  作用域解析符

文件I/O

EOF 文件结尾标志

iostream c++的所有流

Ifstream 文件读取类

Ofstream 文件写入类





（数组越界检查是个问题）



打开文件的列子
！[打开文件的例子](/img/打开文件的例子.png)

### 函数的重载
   函数同样的名字定义不同参数 （参数额个数不同，类型的不同等）
   通过函数的参数进行重载，

### 复杂的数据类型
####   数组 同类型的变量  
   Std::string 字符类型的数组  提取 比较 添加 修改的功能
     指针  变量名不存在内存中 通过编译器实现
           数据类型需要和cpu的位数对齐 比如一个字符m 假如cpu是32位的则内存
                存放m时需要4个字节  
           一个变量可以通过地址找到也可以通过变量名索引   变量在使用时
                地址不发生变化的
           指针变量的数据类型指的是指针指向的数据的类型
           Void *p 表示只是建立一个指针变量（无类型指针 地址中可以存放任何类型
                                               的数据）
           除定义外 *p表示p地址的值
                     *  1用于创建指针 2对指针进行解引用
           通过指针引用数组元素时 指针变量++代表数组按数组类型++
           

 #### 结构体  与c语言中的结构体一样 （创建一个特殊类型），
      指针可以指向结构体  创建一个结构体类型的指针即可  
！[定义结构体](/img/定义结构体.png)

指针访问结构体方式一

![访问方法1](/img/访问方法一.png)

指针指向结构体方法2
![访问方法2](/img/访问方法2.png)


#### 联合 枚举 类型别名

     联合类型 union 类型声明同结构体一样 但是结构体在赋值时只能有一个变量 
     枚举类型 enum 
           
![枚举型](/img/枚举型.png)


类型别名 typedef  例如 typedef int* intpointer 将int*的定义声明变为 intpointer


### 对象  类 

与结构体类似 里面有变量和函数 变量称为属性 函数称为方法

函数需要在类外面进行完成

例如


  ![类](/img/类.png)

构造器 构造器的名字必须和所构造的泪名字一样在结束声明时完成构造器本身

每个类里至少有一个构造器


析构器  一般来说构造器用于初始化和准备工作 析构器用于完事后清理内存
析构器与构造器同名 只不过需要在名字前加符号~

特殊指针 this  针对同名的属性问题

类的继承  子类可以继承基类的功能并且可以添加新的功能 


访问控制 public  访问某个属性加上一个权限 如果某个对象试图调用一个它无权访问
                的函数，编译器将报错


覆盖方法名字不变 方法函数改变就可以了    

重载方法函数的方法函数实现的功能相同但是参数不同


###### 友元关系
需要加 friend 才能使其他类访问被保护的类

静态属性和静态方法
     Static 
This指针是生产的对象的地址
静态属性使用时需要在外部申明

虚方法
New 例 int *point=new int；意思是创建一个指向整型变量的指针
Delete 例 delete point；意思是删除这个指针

抽象方法
同一个函数 实现不同的功能

运算符重载  operator  不改变优先级  相当于重载函数


重载 << (左移)操作符


多继承
子函数继承多个基类

虚继承

# 错误处理调试
     1检查头文件是否包含在内
     2 操作符的优先级
     3 函数返回错误代码
     Climits 给定类型的最大取值

异常处理 assert.h
    
![异常处理](/img/异常处理png)
异常捕获
![异常捕获](/img/异常捕获.png)

### 动态内存管理
没有名字只有地址 地址是运行时分配的  new生成在堆里返回头指针

动态数组

让c++的库函数动态的分配数组大小 new 不必在意数组的容量

![动态数组](/img/动态数组.png) 


## 函数方法返回值
相当于c语言中返回值为指针的函数
（任何函数都不能把它自己的局部变量的指针当做它的返回值）因为
局部变量在栈里当函数调用结束后会自动释放掉栈空间

## 副本构造器 
解决同类型的类相互赋值时可能遇到指针指向的地址重复引起的如果其中一个指针变化而引起另一个指针变化的问题
解决方法就是重载=号操作符 

![副本构造器](/img/副本构造器.png)

强制类型转换
      指向同一个地址的指针  在释放内存时 只需要删除其中一个指针即可

![强制类型转换](/img/强制类型转换.png)


避免内存泄漏

![避免内存泄漏](/img/避免内存泄漏.png)

Int[3000]的地址值只有x知道当x重新赋值后int[3000]的内存就泄漏了

！[foo函数](/img/foo函数.png)
foo函数的作用是1声明一个类类型的局部变量指针x 2申请一个类类型的动态堆空间
    当对函数foo的引用完成后系统自动释放栈空间也就是删除局部变量x 此时申请
    的对空间没有被释放 而且找不到地址 引起了内存泄漏


###命名空间和模块化编程
 通过编译器可以把各个文件合在一起“include”就起到这个作用
 
.h文件包含起来.h .c对于编译器来说都是一样的都可以包含进

 Obj文件中。一个文件应该包含所有它的内容中需要用到的文件

 预编译
   ``` 
#ifndef YUBINAYI

    #define YUBINAYI

    #include <...>

     .....

     .....

    #endif

   ```
在.h文件中可以用以上的定义避免当其他多个.c文件引用到此.h文件时

被多次定义 当第一个文件引用此.h文件后#ifndef不执行，执行#define

饭后往下执行 当第二个文件再次引用此.h文件时此时因为上一个文件

引用已经定义YUBIANYI所以这里不再往下执行

连接和作用域

           存储类 1每个变量都有个存储类 它3决定程序将把变量的值存储到什么地方
            如何存储以及作用域 默认存储类为auto 此类变量存在栈中 容易被
            系统回收
           2 与auto不同的是static变量 该变量在程序的生命周期内一直抱有它的值
           3 extern 全局存在变量
           4 register 变量存在寄存器中速度最快

  
##函数模板
   范型编程
   创建一个函数模板应用于任何数据类型
函数模板的语法

1不能把模板函数分成原型和实现
 



### 容器

向量类型

不用对向量的长度确定 向量可以动态的随长度需要而改变
可以用siae()对向量的长度进行确定
可以用访问数组的方法来访问向量

迭代器
 迭代器是容器中的一种方法
任何一个容器都有对应的迭代器 符号是唯一的 iterator