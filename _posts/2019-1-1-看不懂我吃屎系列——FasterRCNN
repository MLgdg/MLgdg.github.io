---
layout:     post
title:      看不懂我吃屎系列——FasterRCNN
subtitle:   
date:       2019-01-01
author:     高庆东
header-img: img/ceshi.jpg
catalog: true
tags:
    - FasterRCNN
    - 目标检测
    - RPN
    - 非极大值抑制
    - ROIpooling
    - VGG16
    -
    - python

---

看到不懂我吃屎
先整体介绍一下，他是干嘛的，和前提条件，输入时啥输出是啥，然后分别详细介绍，每个功能块的作用，最后介绍如何将这些功能块连接起来

### 整体功能
FasterRCNN主要是是用来做目标检测，具体说就是一张图片上有多个物体，FasterRCNN可以将物体以矩形框的形式框出来同时识别出框出来的物体是啥。  
但是前提是，首先是固定的物体类别，不能有未知的物体。输出结果是框的坐标和每个框的类别。如图所示，同时输入单张图片，不能同时处理多个输入
![框架](/img/FasterRCNN.png)

### 特征提取VGG
第一个是特征提取，首先提取一张图片的特征，使用vgg卷积网络，去掉全连接，输入是一张图片输出是一个多通道的featuremap，注意是一个具体形状如
1*512*32*32，1个512通道大小是32*32的特征数据。
大概使用pytorch构建的模型就长这B样，每个MaxPooling都会使输出的图片相对原始图片缩减2倍

`
class VGG16(nn.Module):
    def __init__(self, bn=False):
        super(VGG16, self).__init__()
        self.conv1 = nn.Sequential(Conv2d(3, 64, 3, same_padding=True, bn=bn),
                                   Conv2d(64, 64, 3, same_padding=True, bn=bn),
                                   nn.MaxPool2d(2))
        self.conv2 = nn.Sequential(Conv2d(64, 128, 3, same_padding=True, bn=bn),
                                   Conv2d(128, 128, 3, same_padding=True, bn=bn),
                                   nn.MaxPool2d(2))
        network.set_trainable(self.conv1, requires_grad=False)
        network.set_trainable(self.conv2, requires_grad=False)
        self.conv3 = nn.Sequential(Conv2d(128, 256, 3, same_padding=True, bn=bn),
                                   Conv2d(256, 256, 3, same_padding=True, bn=bn),
                                   Conv2d(256, 256, 3, same_padding=True, bn=bn),
                                   nn.MaxPool2d(2))
        self.conv4 = nn.Sequential(Conv2d(256, 512, 3, same_padding=True, bn=bn),
                                   Conv2d(512, 512, 3, same_padding=True, bn=bn),
                                   Conv2d(512, 512, 3, same_padding=True, bn=bn),
                                   nn.MaxPool2d(2))
        self.conv5 = nn.Sequential(Conv2d(512, 512, 3, same_padding=True, bn=bn),
                                   Conv2d(512, 512, 3, same_padding=True, bn=bn),
                                   Conv2d(512, 512, 3, same_padding=True, bn=bn))
    def forward(self, im_data):
        # im_data, im_scales = get_blobs(image)
        # im_info = np.array(
        #     [[im_data.shape[1], im_data.shape[2], im_scales[0]]],
        #     dtype=np.float32)
        # data = Variable(torch.from_numpy(im_data)).cuda()
        # x = data.permute(0, 3, 1, 2)
        x = self.conv1(im_data)
        x = self.conv2(x)
        x = self.conv3(x)
        x = self.conv4(x)
        x = self.conv5(x)
        return x
        
`


