---
layout:     post
title:      Python从入门到放弃(4)-代码和解题思路
subtitle:   
date:       2019-11-06
author:     高庆东
header-img: img/ceshi.jpg
catalog: true
tags:
    - Python
    - 算法急转弯
    - 递归
---

### 递归
递归中需要有递归公式和中止条件，根据条件中止返回，根据递归公式列函数方程计算阶乘可以使用递归计算

```
def A(n):
    if n==1:
        return 1
    return A(n-1)*n #递归公式n*(n-1)
```
还有杨辉三角等等，最主要的是确定递归公式和终止条件

### 递归快速排序
```
def fun(s):
    if len(s)<2:
        return s
    right=[]
    light=[]
    tmp=s[0]
    del s[0]
    for i in range(0,len(s)):
        if s[i]<tmp:
            light.append(s[i])
        else:
            right.append(s[i])
    return fun(light)+[tmp]+fun(right)
s=[3,1,2,4,6,8,1,2,3]    
fun(s)
```
### 寻找数据最大值和索引
```
def fun(x,l):
    max_=0
    max_indx=0
    for i in range(l-1):
        max_=x[i]
        max_indx=i
        if x[i]<x[i+1]:
            max_=x[i+1]
            max_indx=i+1    
    return max_,max_indx
a=[1,2,3,1,2,3,2,2,3,21,32,4,6543,432]
a,b=fun(a,len(a))
a,b
```
### 冒泡排序
```
def fun(a,l):
    for i in range(l):
        for j in range(l-1):
            if a[j]>a[j+1]:
                tmp=a[j]
                a[j]=a[j+1]
                a[j+1]=tmp
    return a
a=[1,2,3,2,1,3,43,6,456,2,34]
fun(a,len(a))
```
### 整数回文数
给一个整数判断这个整数是否是回文数，不能转化为字符串  
我的思路是转化为一个整数列表然后对比， 还有的思维是直接对比，取到所谓位然后对应位置对比
```
    def isPalindrome(self, x: int) -> bool:
        if x<0:
            return False
        pill=1
        L=[]
        while pill:
            a=10**pill
            if x%a==x:
                L.append(int(x/(a/10)))
                break
            L.append(int((x%a)/(a/10)))
            pill=pill+1
        for i in range(int(len(L)/2)):
            if L[i]!=L[len(L)-1-i]:
                return False
        return True
```

### 最长回文串
给一个字符串找到最长的回文串  
我的思路就是暴力枚举所有字符串，然后判断，结果超时没通过哈哈哈哈
```
class Solution:
    def longest
    Palindrome(self, s: str) -> str:
        
        L=['']
        for i in range(len(s)):
            for j in range(len(s)):
                jieguo,l =self.ss(s[i:(len(s)-j)])
                if jieguo:
                    if len(L)>0:
                        if len(L[-1])<l:
                            L.append(s[i:(len(s)-j)])
        return L[-1]

    def ss(self,x):
        for i in range(int(len(x)/2)):
            if  x[i]!=x[len(x)-1-i]:
                return False,0
        return True,len(x)
                   
```
###  遍历元素查看元素个数
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
非常经典的，要涉及一个可变的nums if来改变他的值
```
class Solution:
    def compressString(self, S: str) -> str:
        nums=1
        X=S
        S=S+'-'
        l=''
        for i in range(1,len(S)):

            if S[i]==S[i-1]:
                nums=nums+1
            else:
                
                l=l+S[i-1]+str(nums)
                nums=1
                
        return  l if len(l)<len(S)-1 else X
```
            
