---
layout:     post
title:      Python从入门到放弃(2)-常见方法和内建的包
subtitle:   
date:       2019-11-04
author:     高庆东
header-img: img/ceshi.jpg
catalog: true
tags:
    - Python
    - 方法
    - 特殊方法
    - 类方法
---

## 常见方法

### map
map就是可以映射一个方程或者一个计算方法。所以核心是一个方法，还有一个序列

```
def a(x):
    return x**2
map(a(),[1,2,3,4])
结果：1，4，9，16
```
通过help()方式观察：其中返回是个生成器对象，啥是生成器后面介绍。简单来说就是可以使用next()和for循环调用。同时使用list将生成器全部显示。

### format()
简单来说就是可以让字符串实现动态的变化
```
for i in range(3):
    print("这事第{}个i".format(i))  在字符串中加入大括号,不能有内容，每个括号表示一个参数，可以加多个括号，同时format()中需要加入多个参数
```
### set()
可以返回一组数据的不重复的数据，该数据可以被list()函数实例出来，可以用for循环迭代但是不能next()显示，所以不是生成器，通过help()方法查看，还  
有add()方法，
```
a=[1,2,3,1,2,3,1]
b=set(b)
b
结果:set类型的数据
```
### get()
获取字典中key下的value 
```
a={'q':1,'w':2}
a.get('q'，default=2) #如果'q'这个key不在字典a中则返回2
结果：1 
```
字典中的方法有很多这知识其中一个，有些可以通过字面意思就能理解的方法，还有个关键问题，字典中的key是不能重复的。
```
a=[3,2,1]
b={i:j for i,j in enumerate(a)}# 返回一个字典 ，key从0开始

```



### 类方法__call__()
该方可可以让对象调用方法的时候不用写方法名，直接调用，

```
class test(object):
    def __init__(self):
        pass
    def __call__(self,x):
        return x**2
A=test()
A(2)
结果： 4
```

### 类方法__enter__() 和__exit__()
这两个方法大多数式共存的，有这两个方法的的类可以使用`with···as`的方式调用。调用的同时首先执行enter中的内容，其次再  
执行exit中的内容,enter的返回值赋值给as后的变量，exit中需要三个变量用来对异常进行处理
```
class test(object):
    def __init__(self,x):
        print(x)
    def __enter__(self):
        print('enter')
        return self     #一般返回类本身即可
    def __exit__(self,a,b,c):  #异常处理的的方法
        print('exit')
with test(1) as t:
    t
    print(1)
#结果  1   ‘enter’   1 ‘exit’
```

这也是pytorch最核心的方法，可以实现前向传播。在这个方法中，这个方法的灵活使用可以然任方法在对象调用的时候不用写函数名    
### 类装饰器
在类中有个@符号表示装饰器符号，该符号后有一个方法。在执行当前方法前会执行装饰器方法。在python中有几个已经定义的方法，  
装饰的作用就是为方法添加额外的功能。
`@classmethod`,`@staticmethod`,`@property` 。   
> @classmethod 当有它装饰时，该方法中第一个在参数在类实例化的时候表示类自身。

```
class fun():
    w=1
    def f1(self):
        print("f1")
    @classmethod
    def f2(cls,x): #传入的是类自身的参数
        print(x)
        print(cls.w)  #w是类自身的属性
func=fun()  #实例化类，不实例化的话不起作用
func.f2(2)
#结果：2,1
```
> @staticmethod 该方法表示将类中的方法静态化，就是类自身调用和类对象调用是一个效果

```
class fun():
    def f1(self,x):
        print(x)
    @staticmethod
    def f2(self,x):
        print(x)

fun.f2(1,2)  #结果一样，由此可以看出类方法和类对象方法一致。
#结果：2
fun().f2(1,2)
#结果：2
```
> @property 可以将类中的方法当作属性调用

```
class fun():
    def f1(self,x):
        print(x)
    @property  #强制将方法转化为属性调用方式，不能传入多余的参数，可以没有返回值，
    def f2(self):
        return 3
fun().f2
#结果：3
```
> @contextlib.contextmanager 文本装饰器，将方法转化为文本式读取，也就是使用 `with···as` 
必须包含yiled
```
import contextlib 
@contextlib.contextmanager
def fun():
    print(1)
    yield 
    print(3)
with fun() as f:
    f
    print(2)

#结果：1 2 3 #结果显示首先执行`yield`前面部分，其次执行with中的部分，当with推出后执行`yield`后部分。
```

## 内建包
### os 

*命令行包  
```
import os
os.system('mkdir eddie')#和命令行一样，表示在界面中实现命令行的功能，同样参数就是命令行参数,需要加引号
```
*文件读取命令

```
import os
lise_dir=os.listdir('/path')#在path路劲下的所有文件名，构成list
```
有这样一个任务对文件进行重命名  
```
import os
lis=os.listdir('./path')
count=0
for i in lis:
    os.rename(os.path.join('/path',i),os.path.join('/path',"{}.jpg".format(count)))
    count=count+1
```
### sys
```
import sys
sys.path.append('/data/eddie/流量监控/Metis') 将当前工作路径放到系统路劲中

```
### time
用来统计时间还有时间戳 
```
import time
time.time() #返回时间戳，也就是现在距离1970年的浮点秒数 ,当进行减的时候就是计算时间差
```
### urllib
这个包是爬虫专用，挺好的，可以解析url地址，ip等
```
import os 
import os.path
from urllib.parse import urlparse
urls = {
    'devkit': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCdevkit_18-May-2011.tar',
    'trainval_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar',
    'test_images_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar',
    'test_anno_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtestnoimgs_06-Nov-2007.tar',
}
parts = urlparse(urls['devkit'])   #解析url链接 
lename = os.path.basename(parts.path)#取最后的名字
print(lename)
```
