---
layout:     post
title:      Python从入门到放弃(2)-常见方法和内建的包
subtitle:   
date:       2019-11-04
author:     高庆东
header-img: img/ceshi.jpg
catalog: true
tags:
    - Python
    - 方法
    - 特殊方法
    - 类方法
---

## 常见方法

### map
map就是可以映射一个方程或者一个计算方法。所以核心是一个方法，还有一个序列

```
def a(x):
    return x**2
map(a(),[1,2,3,4])
结果：1，4，9，16
```
通过help()方式观察：其中返回是个生成器对象，啥是生成器后面介绍。简单来说就是可以使用next()和for循环调用。同时使用list将生成器全部显示。

### format()
简单来说就是可以让字符串实现动态的变化
```
for i in range(3):
    print("这事第{}个i".format(i))  在字符串中加入大括号,不能有内容，每个括号表示一个参数，可以加多个括号，同时format()中需要加入多个参数
```
### set()
可以返回一组数据的不重复的数据，该数据可以被list()函数实例出来，可以用for循环迭代但是不能next()显示，所以不是生成器，通过help()方法查看，还  
有add()方法，
```
a=[1,2,3,1,2,3,1]
b=set(b)
b
结果:set类型的数据
```
### get()
获取字典中key下的value 
```
a={'q':1,'w':2}
a.get('q'，default=2) #如果'q'这个key不在字典a中则返回2
结果：1 
```
字典中的方法有很多这知识其中一个，有些可以通过字面意思就能理解的方法，还有个关键问题，字典中的key是不能重复的。
```
a=[3,2,1]
b={i:j for i,j in enumerate(a)}# 返回一个字典 ，key从0开始

```



### 类方法__call__()
该方可可以让对象调用方法的时候不用写方法名，直接调用，

```
class test(object):
    def __init__(self):
        pass
    def __call__(self,x):
        return x**2
A=test()
A(2)
结果： 4
```

### 类方法__enter__() 和__exit__()
这两个方法大多数式共存的，有这两个方法的的类可以使用`with···as`的方式调用。调用的同时首先执行enter中的内容，其次再  
执行exit中的内容,enter的返回值赋值给as后的变量，exit中需要三个变量用来对异常进行处理
```
class test(object):
    def __init__(self,x):
        print(x)
    def __enter__(self):
        print('enter')
        return self     #一般返回类本身即可
    def __exit__(self,a,b,c):  #异常处理的的方法
        print('exit')
with test(1) as t:
    t
    print(1)
#结果  1   ‘enter’   1 ‘exit’
```

这也是pytorch最核心的方法，可以实现前向传播。在这个方法中，这个方法的灵活使用可以然任方法在对象调用的时候不用写函数名    
### 类装饰器
在类中有个@符号表示装饰器符号，该符号后有一个方法。在执行当前方法前会执行装饰器方法。在python中有几个已经定义的方法，  
装饰的作用就是为方法添加额外的功能。
`@classmethod`,`@staticmethod`,`@property` 。   
> @classmethod 当有它装饰时，该方法中第一个在参数在类实例化的时候表示类自身。

```
class fun():
    w=1
    def f1(self):
        print("f1")
    @classmethod
    def f2(cls,x): #传入的是类自身的参数
        print(x)
        print(cls.w)  #w是类自身的属性
func=fun()  #实例化类，不实例化的话不起作用
func.f2(2)
#结果：2,1
```
> @staticmethod 该方法表示将类中的方法静态化，就是类自身调用和类对象调用是一个效果

```
class fun():
    def f1(self,x):
        print(x)
    @staticmethod
    def f2(self,x):
        print(x)

fun.f2(1,2)  #结果一样，由此可以看出类方法和类对象方法一致。
#结果：2
fun().f2(1,2)
#结果：2
```
> @property 可以将类中的方法当作属性调用

```
class fun():
    def f1(self,x):
        print(x)
    @property  #强制将方法转化为属性调用方式，不能传入多余的参数，可以没有返回值，
    def f2(self):
        return 3
fun().f2
#结果：3
```
> @contextlib.contextmanager 文本装饰器，将方法转化为文本式读取，也就是使用 `with···as` 
必须包含yiled
```
import contextlib 
@contextlib.contextmanager
def fun():
    print(1)
    yield 
    print(3)
with fun() as f:
    f
    print(2)

#结果：1 2 3 #结果显示首先执行`yield`前面部分，其次执行with中的部分，当with推出后执行`yield`后部分。
```

## 内建包
### os 
模块负责程序与操作系统的交互，提供了访问操作系统底层的接口  
*命令行包  
```
import os
os.system('mkdir eddie')#和命令行一样，表示在界面中实现命令行的功能，同样参数就是命令行参数,需要加引号
```
*文件读取命令

```
import os
lise_dir=os.listdir('/path')#在path路劲下的所有文件名，构成list
```
有这样一个任务对文件进行重命名  
```
import os
lis=os.listdir('./path')
count=0
for i in lis:
    os.rename(os.path.join('/path',i),os.path.join('/path',"{}.jpg".format(count)))
    count=count+1
```
常用的os方法  
其实这些方法都是用来操作系统的方法，这些方法主要都可以在操作系统中找到相似的方法。可以直接使用`os.system()`全部实现
```
os.remove()删除文件
os.rename()重命名文件
os.walk()生成目录树下的所有文件名
os.chdir()改变目录
os.mkdir/makedirs创建目录/多层目录
os.rmdir/removedirs删除目录/多层目录
os.listdir()列出指定目录的文件
os.getcwd()取得当前工作目录
os.chmod()改变目录权限
os.path.basename()去掉目录路径，返回文件名
os.path.dirname()去掉文件名，返回目录路径
os.path.join()将分离的各部分组合成一个路径名
os.path.split()返回（dirname(),basename())元组
os.path.splitext()(返回filename,extension)元组
os.path.getatime\ctime\mtime分别返回最近访问、创建、修改时间
os.path.getsize()返回文件大小
os.path.exists()是否存在
os.path.isabs()是否为绝对路径
os.path.isdir()是否为目录
os.path.isfile()是否为文件
```
### sys
模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境  
```
import sys
sys.path.append('/data/eddie/流量监控/Metis') 将当前工作路径放到系统路劲中

```
常用的一些关于解释器的操作，主要是环境变量和解释器的一些交互
```
sys.argv 命令行参数List，第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息
sys.exit(n) 退出程序，正常退出时exit(0)
sys.hexversion 获取Python解释程序的版本值，16进制格式如：0x020403F0
sys.version 获取Python解释程序的版本信息
sys.maxint 最大的Int值
sys.maxunicode 最大的Unicode值
sys.modules 返回系统导入的模块字段，key是模块名，value是模块
sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform 返回操作系统平台名称
sys.stdout 标准输出
sys.stdin 标准输入
sys.stderr 错误输出
sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix 返回平台独立的python文件安装的位置
sys.byteorder 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'
sys.copyright 记录python版权相关的东西
sys.api_version 解释器的C的API版本
```
### time
用来统计时间还有时间戳 
```
import time
time.time() #返回时间戳，也就是现在距离1970年的浮点秒数 ,当进行减的时候就是计算时间差
```
### urllib
这个包是爬虫专用，挺好的，可以解析url地址，ip等
```
import os 
import os.path
from urllib.parse import urlparse
urls = {
    'devkit': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCdevkit_18-May-2011.tar',
    'trainval_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar',
    'test_images_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar',
    'test_anno_2007': 'http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtestnoimgs_06-Nov-2007.tar',
}
parts = urlparse(urls['devkit'])   #解析url链接 
lename = os.path.basename(parts.path)#取最后的名字
print(lename)
```
